{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, EventEmitter, Directive, Optional, Inject, Input, Output } from '@angular/core';\nimport { registerables, Chart, defaults } from 'chart.js';\nimport { merge } from 'lodash-es';\nimport { BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nconst NG_CHARTS_CONFIGURATION = new InjectionToken('Configuration for ngCharts');\n/**\n * Provide all the default registerable as defined by Chart.js\n */\n\nfunction withDefaultRegisterables(...registerables$1) {\n  return {\n    registerables: [...registerables, ...registerables$1]\n  };\n}\n/**\n * Provide configuration for ngCharts. In most cases, you have to pass it some registerables. So either\n * `withDefaultRegisterables()`, or a custom list of registerables tailored to your needs to reduce bundle size.\n */\n\n\nfunction provideCharts(...configurations) {\n  const config = merge({}, ...configurations);\n  return {\n    provide: NG_CHARTS_CONFIGURATION,\n    useValue: config\n  };\n}\n\nclass ThemeService {\n  constructor() {\n    this.colorschemesOptions = new BehaviorSubject(undefined);\n  }\n\n  setColorschemesOptions(options) {\n    this.pColorschemesOptions = options;\n    this.colorschemesOptions.next(options);\n  }\n\n  getColorschemesOptions() {\n    return this.pColorschemesOptions;\n  }\n\n  static {\n    this.ɵfac = function ThemeService_Factory(t) {\n      return new (t || ThemeService)();\n    };\n\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ThemeService,\n      factory: ThemeService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass BaseChartDirective {\n  constructor(element, zone, themeService, config) {\n    this.zone = zone;\n    this.themeService = themeService;\n    this.type = 'bar';\n    this.plugins = [];\n    this.chartClick = new EventEmitter();\n    this.chartHover = new EventEmitter();\n    this.subs = [];\n    this.themeOverrides = {};\n\n    if (config?.registerables) {\n      Chart.register(...config.registerables);\n    }\n\n    if (config?.defaults) {\n      defaults.set(config.defaults);\n    }\n\n    this.ctx = element.nativeElement.getContext('2d');\n    this.subs.push(this.themeService.colorschemesOptions.pipe(distinctUntilChanged()).subscribe(r => this.themeChanged(r)));\n  }\n\n  ngOnChanges(changes) {\n    const requireRender = ['type'];\n    const propertyNames = Object.getOwnPropertyNames(changes);\n\n    if (propertyNames.some(key => requireRender.includes(key)) || propertyNames.every(key => changes[key].isFirstChange())) {\n      this.render();\n    } else {\n      const config = this.getChartConfiguration(); // Using assign to avoid changing the original object reference\n\n      if (this.chart) {\n        Object.assign(this.chart.config.data, config.data);\n\n        if (this.chart.config.plugins) {\n          Object.assign(this.chart.config.plugins, config.plugins);\n        }\n\n        if (this.chart.config.options) {\n          Object.assign(this.chart.config.options, config.options);\n        }\n      }\n\n      this.update();\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n\n    this.subs.forEach(s => s.unsubscribe());\n  }\n\n  render() {\n    if (this.chart) {\n      this.chart.destroy();\n    }\n\n    return this.zone.runOutsideAngular(() => this.chart = new Chart(this.ctx, this.getChartConfiguration()));\n  }\n\n  update(mode) {\n    if (this.chart) {\n      this.zone.runOutsideAngular(() => this.chart?.update(mode));\n    }\n  }\n\n  hideDataset(index, hidden) {\n    if (this.chart) {\n      this.chart.getDatasetMeta(index).hidden = hidden;\n      this.update();\n    }\n  }\n\n  isDatasetHidden(index) {\n    return this.chart?.getDatasetMeta(index)?.hidden;\n  }\n\n  toBase64Image() {\n    return this.chart?.toBase64Image();\n  }\n\n  themeChanged(options) {\n    this.themeOverrides = options;\n\n    if (this.chart) {\n      if (this.chart.config.options) {\n        Object.assign(this.chart.config.options, this.getChartOptions());\n      }\n\n      this.update();\n    }\n  }\n\n  getChartOptions() {\n    return merge({\n      onHover: (event, active) => {\n        if (!this.chartHover.observed && !this.chartHover.observers?.length) {\n          return;\n        }\n\n        this.zone.run(() => this.chartHover.emit({\n          event,\n          active\n        }));\n      },\n      onClick: (event, active) => {\n        if (!this.chartClick.observed && !this.chartClick.observers?.length) {\n          return;\n        }\n\n        this.zone.run(() => this.chartClick.emit({\n          event,\n          active\n        }));\n      }\n    }, this.themeOverrides, this.options, {\n      plugins: {\n        legend: {\n          display: this.legend\n        }\n      }\n    });\n  }\n\n  getChartConfiguration() {\n    return {\n      type: this.type,\n      data: this.getChartData(),\n      options: this.getChartOptions(),\n      plugins: this.plugins\n    };\n  }\n\n  getChartData() {\n    return this.data ? this.data : {\n      labels: this.labels || [],\n      datasets: this.datasets || []\n    };\n  }\n\n  static {\n    this.ɵfac = function BaseChartDirective_Factory(t) {\n      return new (t || BaseChartDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ThemeService), i0.ɵɵdirectiveInject(NG_CHARTS_CONFIGURATION, 8));\n    };\n\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: BaseChartDirective,\n      selectors: [[\"canvas\", \"baseChart\", \"\"]],\n      inputs: {\n        type: \"type\",\n        legend: \"legend\",\n        data: \"data\",\n        options: \"options\",\n        plugins: \"plugins\",\n        labels: \"labels\",\n        datasets: \"datasets\"\n      },\n      outputs: {\n        chartClick: \"chartClick\",\n        chartHover: \"chartHover\"\n      },\n      exportAs: [\"base-chart\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n}\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng2-charts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BaseChartDirective, NG_CHARTS_CONFIGURATION, ThemeService, provideCharts, withDefaultRegisterables }; //# sourceMappingURL=ng2-charts.mjs.map","map":null,"metadata":{},"sourceType":"module"}